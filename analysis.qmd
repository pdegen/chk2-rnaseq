---
title: "RNASeq Results"
subtitle: "CHK2 Project (Muñoz-Maldonado et al.)"
date: last-modified # display the date of the last edit
author: 
  - name: "Peter Degen"
    orcid: 0009-0004-0706-9200
    affiliation:
      - name: "Center for Rerpoducible Science & Research Synthesis, University of Zurich"
        city: "Zurich"
format:
  html:
    toc: true # add a table of contents
    toc-depth: 4 # show level 1-4 subheadings in the table of contents
    code-fold: true
    df-print: paged # R only
    #df-print: kable # R only
  # pdf: default # cannot render pdf with interactive html
echo: true
---

##

```{r}
#| echo: true
#| code-fold: false

FDR_threshold <- 0.01  # differential expression analysis
FDR_thresh_ora <- 0.05  # over-representation analysis
```
## Run edgeR

```{r}
#| echo: true
#| code-fold: true
#| 
#' Run edgeR
#'
#' @param x: dataframe of counts
#' @param design: design matrix, if "paired" constructs design matrix from data assuming x is of the form: k control cols followed by k treatment cols
#' @param overwrite: logical, whether to overwrite existing results table if present
#' @param filter_expr: logical, whether to remove low counts using edgeR's filterByExpr function
#' @param top_tags: int or "Inf", store the results of the most significant genes only
#' @param lfc: float, logFC threshold when testing for DE
#' @param cols_to_keep: list of output table columns to save
run_edgeR <- function(x,
                      outfile,
                      design,
                      overwrite = FALSE,
                      filter_expr = FALSE,
                      top_tags = "Inf",
                      verbose = FALSE,
                      lfc = 0,
                      cols_to_keep = "all",
                      test = "qlf",
                      meta_only = FALSE,
                      check_gof = FALSE,
                      N_control = 0,
                      N_treat = 0,
                      return_norm_factors = FALSE
                      ) {
  suppressPackageStartupMessages(require("edgeR"))
  suppressPackageStartupMessages(require("limma"))

  rds_file <- gsub("\\.csv$", ".rds", outfile)
  
  # Check if files already exist
  if (!overwrite && file.exists(outfile) && file.exists(rds_file)) {
    print("Existing table not overwritten")
    result <- readRDS(rds_file)
    return(result)
  }

  if (design == "paired") {
    if (ncol(x) %% 2 != 0) {
      stop("Paired-design matrix must have even number of columns")
    }
    N <- ncol(x) / 2
    patient <- factor(c(seq(N), seq(N)))
    condition <- factor(c(rep("N", N), rep("T", N))) # normal vs tumor (control vs treatment)
    design <- model.matrix(~ patient + condition)
  } else if (design == "unpaired") {
    if (ncol(x) %% 2 != 0) {
      stop("Design matrix must have even number of columns")
    }
    N <- ncol(x) / 2
    condition <- factor(c(rep("N", N), rep("T", N)))
    design <- model.matrix(~condition)
  } else if (design == "unpaired_asymmetric") {
    if (N_control == 0) {
      stop("Design matrix has no control columns")
    }
    if (N_treat == 0) {
      stop("Design matrix has no treatment/condition columns")
    }
    condition <- factor(c(rep("N", N_control), rep("T", N_treat)))
    design <- model.matrix(~condition)
  } else if (grepl("\\.csv$", design, ignore.case = TRUE)) {
    print("Constructing design matrix from df")
    covariate_df <- read.csv(design)
    if (!("Condition" %in% colnames(covariate_df))) {
      stop("Error: 'Condition' column not found in dataframe")
    }

    covariate_df <- covariate_df %>%
      mutate_if(is.character, as.factor)

    # Relevel 'Condition' so that its first level is used as the reference
    first_condition <- as.character(covariate_df$Condition[1])
    print(paste("Reference condition:", first_condition))
    covariate_df$Condition <- relevel(covariate_df$Condition, ref = first_condition)
    other_vars <- setdiff(names(covariate_df), c("Condition", "X", "Sample"))
    #print("Warning: hard-coded col names in design matrix")
    formula <- as.formula(paste("~", paste(c(other_vars, "Condition"), collapse = " + ")))
    print(paste("Formula:", formula))
    design <- model.matrix(formula, data = covariate_df)
    # Ensure your count matrix and metadata align
    if ("X" %in% names(covariate_df)) {
      rownames(covariate_df) <- covariate_df$X
    } else if ("Sample" %in% names(covariate_df)) {
      rownames(covariate_df) <- covariate_df$Sample
    } else {
      stop("Sample names not found in covariate df")
    }
  }

  if (verbose) {
    rank <- qr(design)$rank
    print(paste("Rank:", rank, "Cols:", ncol(design)))
    print(design)
  }

  y <- DGEList(counts = x)
  rownames(design) <- colnames(y)

  if (filter_expr) {
    keep <- filterByExpr(y, design = design)
    y <- y[keep, , keep.lib.sizes = FALSE]
  }

  y <- calcNormFactors(y)

  if (return_norm_factors) {
    return(y$samples$norm.factors)
  }
  y <- estimateDisp(y, design, robust = TRUE)

  if (meta_only) {
    return(y)
  }

  if (test == "lrt") {
    fit <- glmFit(y, design)
  } else {
    fit <- glmQLFit(y, design)
  }

  # Goodness-of-fit
  if (check_gof) {
    res.gof <- gof(fit, plot = FALSE)
    file_name <- basename(outfile)
    new_file_name <- paste0("gof.", file_name)
    new_file_path <- file.path(dirname(outfile), new_file_name)
    write.csv(res.gof$gof.pvalues, new_file_path)
    print(paste("Saved gof in", new_file_path))
  }

  if (lfc > 0) {
    result <- glmTreat(fit, lfc = lfc)
  } else if (test == "lrt") {
    result <- glmLRT(fit)
  } else {
    result <- glmQLFTest(fit)
  } # omit coef (edgeR user's guide p. 39)

  table <- topTags(result, n = top_tags) # adjust.method="BH"

  if (any(cols_to_keep != "all")) {
    if (typeof(cols_to_keep) == "list") cols_to_keep <- unlist(cols_to_keep)
    table <- table[, cols_to_keep]
  }
  write.csv(table, outfile)
  #result_y <- list(result = result, y = y)
  result$y <- y
  saveRDS(result, file = rds_file)
  result
}

# 2022 originaö analysis with manual pipeline
x <- read.csv("data/GSE303774_raw_counts.csv", row.names=1)
outfile <- "data/edger_table.csv"

# 2025 re-analysis with nf-core
# x <- read.table(file = "data/kallisto.merged.gene_counts.tsv", sep = '\t', header = TRUE)
# row.names(x) <- x$gene_id
# x$gene_id <- NULL
# x$gene_name <- NULL
# cols_WT <- grep("^Par", names(x), value = TRUE)
# cols_KO <- grep("^KO", names(x), value = TRUE)
# names(x)[names(x) %in% cols_WT] <- sub("^Par", "WT", cols_WT)
# x <- x[, c(sub("^Par", "WT", cols_WT), cols_KO)]
# outfile <- "data/edger_table_nfc.csv"

design <- "paired"
result <- run_edgeR(x,
                    outfile,
                    design,
                    overwrite = TRUE,
                    filter_expr = TRUE,
                    top_tags = "Inf",
                    verbose = FALSE,
                    lfc = 0,
                    cols_to_keep = "all",
                    test = "qlf",
                    meta_only = FALSE,
                    check_gof = FALSE,
                    N_control = 0,
                    N_treat = 0,
                    return_norm_factors = FALSE
                    )

tab <- read.csv(outfile, row.names=1)
sig <- tab[tab$FDR<FDR_threshold, ]
nsig <- nrow(sig)
nup <- nrow(sig[sig$logFC>0, ])
ndown <- nrow(sig[sig$logFC<0, ])

cat("Results available in: ", outfile)
```

```{r}
#| echo: false
cat("Significant genes: ", nsig, " (up: ", nup, ", down: ", ndown, ")")
```

## Figures

### Mean-difference plot

```{r}
plotMD(result, p.value=FDR_threshold, adjust.method="BH", main="KO vs WT")
```

### MDS plot

From edgeRR documentation:

"The function `plotMDS` draws a multi-dimensional scaling plot of the RNA samples in which distances correspond to leading log-fold-changes between each pair of RNA samples. The leading log-fold-change is the average (root-mean-square) of the largest absolute log-fold-changes between each pair of samples. This plot can be viewed as a type of unsupervised clustering."

```{r}
plotMDS(result$y)
```
### Library sizes

```{r}
barplot(result$y$samples$lib.size*1e-6, names=rownames(result$y$samples), ylab="Library size (millions)")
```
### BCV plot

```{r}
plotBCV(result$y)
```
### Gene symbols

Our original data frame uses Ensemble gene identifiers (ENSG). Further below, we will also need gene symbols and Entrez identifiers. The identifiers were originally fetched using biomart, but here we will simply load a cached conversion table with all identifiers.

```{r}
library(dplyr)
library(tibble)

conv <- read.csv("data/conv_table.csv")
if (!"Symbol" %in% colnames(tab)) {
  tab <- tab %>%
    rownames_to_column("ENSG") %>%
    left_join(conv %>% select(ENSG, Symbol, Entrez), by = "ENSG") %>% 
    select(ENSG, Symbol, Entrez, logFC, logCPM, F, PValue, FDR)
}
head(tab)
```

### DDR heatmap

First, we fetch a cached list of DDR processes and associated terms (oiginally obtained from [https://www.mdanderson.org/documents/Labs/Wood-Laboratory/human-dna-repair-genes.html](https://www.mdanderson.org/documents/Labs/Wood-Laboratory/human-dna-repair-genes.html)).

```{r}
#| echo: true
#| code-fold: true

library(httr)
library(rvest)
library(dplyr)
library(stringr)

get_tab_ddrle <- function(outfile) {
  
  if (file.exists(outfile)) {
    print("Loading existing DDR table")
    ddr_df <- read.csv(outfile, row.names=1)
    return(ddr_df)
  }
  
  # Fetch and parse HTML
  url <- "https://www.mdanderson.org/documents/Labs/Wood-Laboratory/human-dna-repair-genes.html"
  page <- GET(url)
  html <- read_html(content(page, as = "text"))
  
  # Extract first table
  tab_ddr <- html %>%
    html_table(fill = TRUE) %>%
    .[[1]] %>%
    pull(1) %>%
    as.character()
  
  # Preprocess entries
  ddr_vec <- tab_ddr[3:(length(tab_ddr) - 1)]
  ddr_list <- c()
  for (d in ddr_vec) {
    if (d == "Poly(ADP-ribose) polymerase (PARP) enzymes that bind to DNA") {
      ddr_list <- c(ddr_list, d)
      next
    }
    parts <- str_split(d, "\\(")[[1]]
    parts <- str_replace(parts, "\\)", "")
    parts <- str_trim(parts)
    ddr_list <- c(ddr_list, parts)
  }
  
  # Fix one special case
  ddr_list <- ddr_list[ddr_list != "XLF, Cernunnos"]
  ddr_list <- c(ddr_list, "XLF", "Cernunnos")
  ddr_list <- ddr_list[!is.na(ddr_list) & ddr_list != "nan"]
  
  # Build named list
  ddr_dict <- list()
  key <- NULL
  for (ddr in ddr_list) {
    if (str_detect(ddr, " ")) {
      key <- ddr
      ddr_dict[[key]] <- character()
    } else {
      ddr_dict[[key]] <- c(ddr_dict[[key]], ddr)
    }
  }
  
  # Convert to data frame
  ddr_df <- as.data.frame(do.call(rbind, lapply(ddr_dict, `length<-`, max(lengths(ddr_dict)))))
  ddr_df <- t(ddr_df)
  rownames(ddr_df) <- NULL
  colnames(ddr_df) <- names(ddr_dict)
  ddr_df <- as.data.frame(ddr_df)
  write.csv(ddr_df, outfile)
  ddr_df
}

ddr_df <- get_tab_ddrle("data/ddr.csv")
```
```{r}
library(tidyr)

ddr_long <- ddr_df %>%
  mutate(row = row_number()) %>%
  pivot_longer(-row, names_to = "DDR_Process", values_to = "Symbol") %>%
  filter(!is.na(Symbol), Symbol != "") %>%
  distinct(Symbol, DDR_Process)

tab$DDR_Process <- NULL
tab <- tab %>%
  left_join(ddr_long %>% select(Symbol, DDR_Process), by = "Symbol")

tab_ddr <- subset(tab, !is.na(DDR_Process))

sig_ddr <- tab_ddr[tab_ddr$FDR<FDR_threshold, ]
nsig_ddr <- nrow(sig_ddr)
nup_ddr <- nrow(sig_ddr[sig_ddr$logFC>0, ])
ndown_ddr <- nrow(sig_ddr[sig_ddr$logFC<0, ])

cat("Significant DDR genes: ", nsig_ddr, " (up: ", nup_ddr, ", down: ", ndown_ddr, ")")

tab_ddr
```

```{r}
library(pheatmap)
y <- result$y
logCPM <- cpm(y, prior.count=2, log=TRUE)
colnames(logCPM) <- c("CHK2 WT","CHK2 WT","CHK2 WT","CHK2 KO","CHK2 KO","CHK2 KO")#rownames(y$samples)
sig_ddr_logCPM <- logCPM[rownames(logCPM) %in% sig_ddr$ENSG, ]
rownames(sig_ddr_logCPM) <- sig_ddr$Symbol[match(rownames(sig_ddr_logCPM), sig_ddr$ENSG)]
pheatmap(sig_ddr_logCPM,
         scale = "row",         # z-score normalize each gene
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         fontsize_row = 8,
         fontsize_col = 8,
         angle_col = 0,
         main = "DDR Gene Expression (logCPM z-score)")

```

## Interacting genes

```{r}
interacting_genes <- c("VASP","TP53","CHEK2","ITPR1","PPP1R12A","MDM2",
"BRCA1","CDC25C","PRKG1","MDC1","TP53BP1","ATM","RAP1GAP2","GTF2I")

tab[tab$Symbol %in% interacting_genes, ]
```

## Overrepresentation analysis

### Gene ontology

Gene ontology results obtained by running `goana` function from the edgeR package.  DEGs at 1% FDR are used as input. Significant GO terms are defined using a 5% FDR threshold.

```{r}
entrez <- tab[match(row.names(result$table), tab$ENSG), ]$Entrez

go <- goana(result, FDR=FDR_threshold, geneid=entrez, species="Hs")  # use DE FDR threshold here

go$FDR.Up <- p.adjust(go$P.Up, method = "BH")
go$FDR.Down <- p.adjust(go$P.Down, method = "BH")

go_sig_up <- go[go$FDR.Up<FDR_thresh_ora, ]
go_sig_down <- go[go$FDR.Down<FDR_thresh_ora, ]

cat("GO terms tested: ", nrow(go) , " | Signficant Up: ", nrow(go_sig_up), ", Down: ", nrow(go_sig_down))
go_sig <- go[go$FDR.Down<FDR_thresh_ora | go$FDR.Up<FDR_thresh_ora, ]
#topGO(go, ont="BP", sort="up")
go_sig
```

### KEGG

KEGG results obtained by running `kegga` function from the edgeR package. DEGs at 1% FDR are used as input. Significant KEGG pathways are defined using a 5% FDR threshold.


```{r}
#kegg <- kegga(result_flipped, FDR=FDR_threshold, geneid=entrez, species="Hs")
kegg <- kegga(result, FDR=FDR_threshold, geneid=entrez, species="Hs")
# For some reason, kegga doesn't return pathway names, so fill in from old results file
if (file.exists("data/kegg.csv")) {
  kegg_old <- read.csv("data/kegg.csv", row.names = 1)
  
  # Make sure row names match and 'Pathway' column exists in both
  if ("Pathway" %in% colnames(kegg_old) && "Pathway" %in% colnames(kegg)) {
    matching_rows <- intersect(rownames(kegg), rownames(kegg_old))
    
    # Replace empty or NA Pathway values in 'kegg' with those from 'kegg_old'
    empty_or_na <- is.na(kegg[matching_rows, "Pathway"]) | kegg[matching_rows, "Pathway"] == ""
    kegg[matching_rows[empty_or_na], "Pathway"] <- kegg_old[matching_rows[empty_or_na], "Pathway"]
  }
}


kegg$FDR.Up <- p.adjust(kegg$P.Up, method = "BH")
kegg$FDR.Down <- p.adjust(kegg$P.Down, method = "BH")

kegg_sig_up <- kegg[kegg$FDR.Up<FDR_thresh_ora, ]
kegg_sig_down <- kegg[kegg$FDR.Down<FDR_thresh_ora, ]

cat("KEGG terms tested: ", nrow(kegg) , " | Signficant Up: ", nrow(kegg_sig_up), ", Down: ", nrow(kegg_sig_down))
kegg_sig <- kegg[kegg$FDR.Down<FDR_thresh_ora | kegg$FDR.Up<FDR_thresh_ora, ]
#topKEGG(kegg)
kegg_sig
```

#### KEGG Term: DNA replication

To make sure the signs are correct, let's inspect the edgeR table and raw gene counts for the downregulated KEGG pathway `hsa03030` (DNA replication):

```{r}
hsa03030_genes <- c("10535","10714","1763","2237","23649","246243",
"29935","3978","4171","4172","4173","4174","4175","4176","5111","54107",
"5422","5424","5425","5426","5427","5557","5558","56655","57804","5981",
"5982","5983","5984","5985","6117","6118","6119","6742","79621","84153")

cat("Genes in pathway:", length(hsa03030_genes),"\n")
tab_hs <- tab[tab$Entrez %in% hsa03030_genes, ]
cat("Matched genes in pathway:", nrow(tab_hs), "/", length(hsa03030_genes),"\n")
tab_hs_sig <- tab_hs[tab_hs$FDR<FDR_threshold, ]
cat("Significant genes in pathway:", nrow(tab_hs_sig), "/", length(hsa03030_genes),"\n")
tab_hs_sig
x[tab_hs_sig$ENSG, ]
```

#### Comparison with 2022 KEGG results

The original KEGG analysis from 2022 used a different version of KEGG with fewer pathways (347 instead of 367). Here a comparison of the new and old KEGG results:

```{r}

kegg_old <- read.csv("data/kegg.csv", row.names=1)
FDR_thresh_ora <- 0.05

kegg_old_sig_up <- kegg_old[kegg_old$FDR.Up<FDR_thresh_ora, ]
kegg_old_sig_down <- kegg_old[kegg_old$FDR.Down<FDR_thresh_ora, ]

cat("KEGG terms tested (2022): ", nrow(kegg_old) , " | Signficant Up: ", nrow(kegg_old_sig_up), ", Down: ", nrow(kegg_old_sig_down))
kegg_sig_old <- kegg_old[kegg_old$FDR.Down<FDR_thresh_ora | kegg_old$FDR.Up<FDR_thresh_ora, ]

```


```{r}
compare_row_names <- function(df1, df2, colname="", cats = c("df1", "df2")) {
  
  if (colname != "") {
   r1 <- df1[[colname]] 
   r2 <- df2[[colname]]
  } else {
    r1 <- rownames(df1)
    r2 <- rownames(df2)
  }
  
  # Intersection and union
  intersection <- intersect(r1, r2)
  union_set <- union(r1, r2)
  sym_diff <- setdiff(union_set, intersection)

  # Print sizes
  cat("Intersection size:", length(intersection), "\n")
  cat("Union size:", length(union_set), "\n")
  cat("Symmetric difference size:", length(sym_diff), "\n\n")

  # Symmetric difference table
  sym_table <- data.frame(
    RowName = sym_diff,
    setNames(list(sym_diff %in% r1), paste0("In ", cats[[1]])),
    setNames(list(sym_diff %in% r2), paste0("In ", cats[[2]]))
  )

  # Load VennDiagram library
  if (!requireNamespace("VennDiagram", quietly = TRUE)) {
    install.packages("VennDiagram")
  }
  library(VennDiagram)

  # Plot Venn
  grid.newpage()
  draw.pairwise.venn(
    area1 = length(r1),
    area2 = length(r2),
    cross.area = length(intersection),
    category = cats,
    fill = c("skyblue", "pink"),
    alpha = c(0.5, 0.5),
    cat.cex = 1.2,
    cex = 1.2,
    cat.pos = c(-20, 20)
  )
  
  sym_table
}

compare_row_names(kegg_sig, kegg_sig_old, colname="Pathway", cats=c("New_2025", "Original_2022"))
```

## Save results

```{r}
#| echo: true
#| code-fold: false
#| 
write.csv(tab, "data/edgeR_table_annotated.csv")
write.csv(go, "data/go_table.csv")
write.csv(kegg, "data/kegg_table.csv")
```

## Session Info

```{r}
sink("session_info.txt")
sessionInfo()
sink()
sessionInfo()
```

