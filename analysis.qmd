---
title: "RNASeq Results"
subtitle: "CHK2 Project (Mu√±oz-Maldonado et al.)"
date: last-modified # display the date of the last edit
author: 
  - name: "Peter Degen"
    orcid: 0009-0004-0706-9200
    affiliation:
      - name: "Center for Rerpoducible Science, University of Zurich"
        city: "Zurich"
format:
  html:
    toc: true # add a table of contents
    toc-depth: 4 # show level 1-4 subheadings in the table of contents
    code-fold: true
    df-print: paged # R only
    #df-print: kable # R only
  # pdf: default # cannot render pdf with interactive html
echo: false
---

##

```{r}
#| echo: true
#| code-fold: false
FDR_threshold <- 0.01
```

## Run edgeR

```{r}
#| echo: true
#| code-fold: true
#| 
#' Run edgeR
#'
#' @param x: dataframe of counts
#' @param design: design matrix, if "paired" constructs design matrix from data assuming x is of the form: k control cols followed by k treatment cols
#' @param overwrite: logical, whether to overwrite existing results table if present
#' @param filter_expr: logical, whether to remove low counts using edgeR's filterByExpr function
#' @param top_tags: int or "Inf", store the results of the most significant genes only
#' @param lfc: float, logFC threshold when testing for DE
#' @param cols_to_keep: list of output table columns to save
run_edgeR <- function(x,
                      outfile,
                      design,
                      overwrite = FALSE,
                      filter_expr = FALSE,
                      top_tags = "Inf",
                      verbose = FALSE,
                      lfc = 0,
                      cols_to_keep = "all",
                      test = "qlf",
                      meta_only = FALSE,
                      check_gof = FALSE,
                      N_control = 0,
                      N_treat = 0,
                      return_norm_factors = FALSE
                      ) {
  suppressPackageStartupMessages(require("edgeR"))
  suppressPackageStartupMessages(require("limma"))

  rds_file <- gsub("\\.csv$", ".rds", outfile)
  
  # Check if files already exist
  if (!overwrite && file.exists(outfile) && file.exists(rds_file)) {
    print("Existing table not overwritten")
    result <- readRDS(rds_file)
    return(result)
  }

  if (design == "paired") {
    if (ncol(x) %% 2 != 0) {
      stop("Paired-design matrix must have even number of columns")
    }
    N <- ncol(x) / 2
    patient <- factor(c(seq(N), seq(N)))
    condition <- factor(c(rep("N", N), rep("T", N))) # normal vs tumor (control vs treatment)
    design <- model.matrix(~ patient + condition)
  } else if (design == "unpaired") {
    if (ncol(x) %% 2 != 0) {
      stop("Design matrix must have even number of columns")
    }
    N <- ncol(x) / 2
    condition <- factor(c(rep("N", N), rep("T", N)))
    design <- model.matrix(~condition)
  } else if (design == "unpaired_asymmetric") {
    if (N_control == 0) {
      stop("Design matrix has no control columns")
    }
    if (N_treat == 0) {
      stop("Design matrix has no treatment/condition columns")
    }
    condition <- factor(c(rep("N", N_control), rep("T", N_treat)))
    design <- model.matrix(~condition)
  } else if (grepl("\\.csv$", design, ignore.case = TRUE)) {
    print("Constructing design matrix from df")
    covariate_df <- read.csv(design)
    if (!("Condition" %in% colnames(covariate_df))) {
      stop("Error: 'Condition' column not found in dataframe")
    }

    covariate_df <- covariate_df %>%
      mutate_if(is.character, as.factor)

    # Relevel 'Condition' so that its first level is used as the reference
    first_condition <- as.character(covariate_df$Condition[1])
    print(paste("Reference condition:", first_condition))
    covariate_df$Condition <- relevel(covariate_df$Condition, ref = first_condition)
    other_vars <- setdiff(names(covariate_df), c("Condition", "X", "Sample"))
    #print("Warning: hard-coded col names in design matrix")
    formula <- as.formula(paste("~", paste(c(other_vars, "Condition"), collapse = " + ")))
    print(paste("Formula:", formula))
    design <- model.matrix(formula, data = covariate_df)
    
    # Ensure your count matrix and metadata align
    if ("X" %in% names(covariate_df)) {
      rownames(covariate_df) <- covariate_df$X
    } else if ("Sample" %in% names(covariate_df)) {
      rownames(covariate_df) <- covariate_df$Sample
    } else {
      stop("Sample names not found in covariate df")
    }
  }

  if (verbose) {
    rank <- qr(design)$rank
    print(paste("Rank:", rank, "Cols:", ncol(design)))
    print(design)
  }

  y <- DGEList(counts = x)

  rownames(design) <- colnames(y)

  if (filter_expr) {
    keep <- filterByExpr(y, design = design)
    y <- y[keep, , keep.lib.sizes = FALSE]
  }

  y <- calcNormFactors(y)

  if (return_norm_factors) {
    return(y$samples$norm.factors)
  }
  y <- estimateDisp(y, design, robust = TRUE)

  if (meta_only) {
    return(y)
  }

  if (test == "lrt") {
    fit <- glmFit(y, design)
  } else {
    fit <- glmQLFit(y, design)
  }

  # Goodness-of-fit
  if (check_gof) {
    res.gof <- gof(fit, plot = FALSE)
    file_name <- basename(outfile)
    new_file_name <- paste0("gof.", file_name)
    new_file_path <- file.path(dirname(outfile), new_file_name)
    write.csv(res.gof$gof.pvalues, new_file_path)
    print(paste("Saved gof in", new_file_path))
  }

  if (lfc > 0) {
    result <- glmTreat(fit, lfc = lfc)
  } else if (test == "lrt") {
    result <- glmLRT(fit)
  } else {
    result <- glmQLFTest(fit)
  } # omit coef (edgeR user's guide p. 39)

  table <- topTags(result, n = top_tags) # adjust.method="BH"

  if (any(cols_to_keep != "all")) {
    if (typeof(cols_to_keep) == "list") cols_to_keep <- unlist(cols_to_keep)
    table <- table[, cols_to_keep]
  }
  write.csv(table, outfile)
  #result_y <- list(result = result, y = y)
  result$y <- y
  saveRDS(result, file = rds_file)
  result
}

x <- read.csv("data/counts.csv", row.names=1)
outfile <- "data/edger_table.csv"
design <- "paired"
result <- run_edgeR(x,
                    outfile,
                    design,
                    overwrite = TRUE,
                    filter_expr = TRUE,
                    top_tags = "Inf",
                    verbose = FALSE,
                    lfc = 0,
                    cols_to_keep = "all",
                    test = "qlf",
                    meta_only = FALSE,
                    check_gof = FALSE,
                    N_control = 0,
                    N_treat = 0,
                    return_norm_factors = FALSE
                    )

tab <- read.csv(outfile, row.names=1)
sig <- tab[tab$FDR<FDR_threshold, ]
nsig <- nrow(sig)
nup <- nrow(sig[sig$logFC>0, ])
ndown <- nrow(sig[sig$logFC<0, ])

print(paste0("Results available in: ", outfile))
print(paste0("Significant genes: ", nsig, " (up: ", nup, ", down: ", ndown, ")"))

```
## Figures

### Mean-difference plot

```{r}
plotMD(result, p.value=FDR_threshold, adjust.method="BH", main="KO vs WT")
```

### MDS plot

From edgeRR documentation:

"The function `plotMDS` draws a multi-dimensional scaling plot of the RNA samples in which distances correspond to leading log-fold-changes between each pair of RNA samples. The leading log-fold-change is the average (root-mean-square) of the largest absolute log-fold-changes between each pair of samples. This plot can be viewed as a type of unsupervised clustering."

```{r}
plotMDS(result$y)
```
### Library sizes

```{r}
barplot(result$y$samples$lib.size*1e-6, names=rownames(result$y$samples), ylab="Library size (millions)")
```
### BCV plot

```{r}
plotBCV(result$y)
```
### Gene symbols

Our original data frame uses Ensemble gene identifiers (ENSG). Further below, we will also need gene symbols and Entrez identifiers. The identifiers were originally fetched using biomart, but here we will simply load a cached conversion table with all identifiers.

```{r}
library(dplyr)
library(tibble)

conv <- read.csv("data/conv_table.csv")
if (!"Symbol" %in% colnames(tab)) {
  tab <- tab %>%
    rownames_to_column("ENSG") %>%
    left_join(conv %>% select(ENSG, Symbol, Entrez), by = "ENSG") %>% 
    select(ENSG, Symbol, Entrez, logFC, logCPM, F, PValue, FDR)
}
head(tab)
```

### DDR heatmap

First, we fetch a cached list of DDR processes and associated terms (oiginally obtained from [https://www.mdanderson.org/documents/Labs/Wood-Laboratory/human-dna-repair-genes.html](https://www.mdanderson.org/documents/Labs/Wood-Laboratory/human-dna-repair-genes.html)).

```{r}
#| echo: true
#| code-fold: true

library(httr)
library(rvest)
library(dplyr)
library(stringr)

get_tab_ddrle <- function(outfile) {
  
  if (file.exists(outfile)) {
    print("Loading existing DDR table")
    ddr_df <- read.csv(outfile, row.names=1)
    return(ddr_df)
  }
  
  # Fetch and parse HTML
  url <- "https://www.mdanderson.org/documents/Labs/Wood-Laboratory/human-dna-repair-genes.html"
  page <- GET(url)
  html <- read_html(content(page, as = "text"))
  
  # Extract first table
  tab_ddr <- html %>%
    html_table(fill = TRUE) %>%
    .[[1]] %>%
    pull(1) %>%
    as.character()
  
  # Preprocess entries
  ddr_vec <- tab_ddr[3:(length(tab_ddr) - 1)]
  ddr_list <- c()
  for (d in ddr_vec) {
    if (d == "Poly(ADP-ribose) polymerase (PARP) enzymes that bind to DNA") {
      ddr_list <- c(ddr_list, d)
      next
    }
    parts <- str_split(d, "\\(")[[1]]
    parts <- str_replace(parts, "\\)", "")
    parts <- str_trim(parts)
    ddr_list <- c(ddr_list, parts)
  }
  
  # Fix one special case
  ddr_list <- ddr_list[ddr_list != "XLF, Cernunnos"]
  ddr_list <- c(ddr_list, "XLF", "Cernunnos")
  ddr_list <- ddr_list[!is.na(ddr_list) & ddr_list != "nan"]
  
  # Build named list
  ddr_dict <- list()
  key <- NULL
  for (ddr in ddr_list) {
    if (str_detect(ddr, " ")) {
      key <- ddr
      ddr_dict[[key]] <- character()
    } else {
      ddr_dict[[key]] <- c(ddr_dict[[key]], ddr)
    }
  }
  
  # Convert to data frame
  ddr_df <- as.data.frame(do.call(rbind, lapply(ddr_dict, `length<-`, max(lengths(ddr_dict)))))
  ddr_df <- t(ddr_df)
  rownames(ddr_df) <- NULL
  colnames(ddr_df) <- names(ddr_dict)
  ddr_df <- as.data.frame(ddr_df)
  write.csv(ddr_df, outfile)
  ddr_df
}

ddr_df <- get_tab_ddrle("data/ddr.csv")
```
```{r}
library(tidyr)

ddr_long <- ddr_df %>%
  mutate(row = row_number()) %>%
  pivot_longer(-row, names_to = "DDR_Process", values_to = "Symbol") %>%
  filter(!is.na(Symbol), Symbol != "") %>%
  distinct(Symbol, DDR_Process)

tab$DDR_Process <- NULL
tab <- tab %>%
  left_join(ddr_long %>% select(Symbol, DDR_Process), by = "Symbol")

tab_ddr <- subset(tab, !is.na(DDR_Process))

sig_ddr <- tab_ddr[tab_ddr$FDR<FDR_threshold, ]
nsig_ddr <- nrow(sig_ddr)
nup_ddr <- nrow(sig_ddr[sig_ddr$logFC>0, ])
ndown_ddr <- nrow(sig_ddr[sig_ddr$logFC<0, ])

print(paste0("Significant DDR genes: ", nsig_ddr, " (up: ", nup_ddr, ", down: ", ndown_ddr, ")"))

tab_ddr
```

```{r}
library(pheatmap)
y <- result$y
logCPM <- cpm(y, prior.count=2, log=TRUE)
colnames(logCPM) <- c("CHK2 WT","CHK2 WT","CHK2 WT","CHK2 KO","CHK2 KO","CHK2 KO")#rownames(y$samples)
sig_ddr_logCPM <- logCPM[rownames(logCPM) %in% sig_ddr$ENSG, ]
rownames(sig_ddr_logCPM) <- sig_ddr$Symbol[match(rownames(sig_ddr_logCPM), sig_ddr$ENSG)]
pheatmap(sig_ddr_logCPM,
         scale = "row",         # z-score normalize each gene
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         fontsize_row = 8,
         fontsize_col = 8,
         angle_col = 0,
         main = "DDR Gene Expression (logCPM z-score)")

```

## Interacting genes

```{r}
interacting_genes <- c("VASP","TP53","CHEK2","ITPR1","PPP1R12A","MDM2",
"BRCA1","CDC25C","PRKG1","MDC1","TP53BP1","ATM","RAP1GAP2","GTF2I")

tab[tab$Symbol %in% interacting_genes, ]
```

## Overrepresentation analysis

### Gene ontology

```{r}
FDR_thresh_ora <- 0.05
entrez <- tab[match(row.names(result$table), tab$ENSG), ]$Entrez

go <- goana(result, FDR=FDR_thresh_ora, geneid=entrez, species="Hs")

go$FDR.Up <- p.adjust(go$P.Up, method = "BH")
go$FDR.Down <- p.adjust(go$P.Down, method = "BH")

go_sig_up <- go[go$FDR.Up<FDR_thresh_ora, ]
go_sig_down <- go[go$FDR.Down<FDR_thresh_ora, ]

print(paste0("GO terms tested: ", nrow(go) , " | Signficant Up: ", nrow(go_sig_up), ", Down: ", nrow(go_sig_down)))
go[go$FDR.Down<FDR_thresh_ora | go$FDR.Up<FDR_thresh_ora, ]
```

### KEGG

```{r}
kegg <- kegga(result, FDR=FDR_thresh_ora, geneid=entrez, species="Hs")

kegg$FDR.Up <- p.adjust(kegg$P.Up, method = "BH")
kegg$FDR.Down <- p.adjust(kegg$P.Down, method = "BH")

kegg_sig_up <- kegg[kegg$FDR.Up<FDR_thresh_ora, ]
kegg_sig_down <- kegg[kegg$FDR.Down<FDR_thresh_ora, ]

print(paste0("KEGG terms tested: ", nrow(kegg) , " | Signficant Up: ", nrow(kegg_sig_up), ", Down: ", nrow(kegg_sig_down)))
kegg[kegg$FDR.Down<FDR_thresh_ora | kegg$FDR.Up<FDR_thresh_ora, ]
```

```{r}
# go2 <- read.csv("data/kegg.csv", row.names=1)
# go2 <- read.csv("data/goana.csv", row.names=1)
# print(nrow(go2))
# 
# print(nrow(go2[go2$FDR.Down<FDR_thresh_ora, ]))
# print(nrow(go2[go2$FDR.Up<FDR_thresh_ora, ]))
# print(nrow(go2[go2$P.Down<FDR_thresh_ora, ]))
# print(nrow(go2[go2$P.Up<FDR_thresh_ora, ]))
# 
# setdiff <- setdiff(row.names(kegg), row.names(go2))
# #setdiff(row.names(go), row.names(go2))
# length(setdiff)
```

## Save results

```{r}
#| echo: true
#| code-fold: false
#| 
write.csv(tab, "data/edgeR_table_annotated.csv")
write.csv(go, "data/go_table.csv")
write.csv(kegg, "data/kegg_table.csv")
```

## Session Info

```{r}
sink("session_info.txt")
sessionInfo()
sink()
```

